"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var credentialDerivation_1 = require("./credentialDerivation");
var getCanonicalHeaders_1 = require("./getCanonicalHeaders");
var getCanonicalQuery_1 = require("./getCanonicalQuery");
var getPayloadHash_1 = require("./getPayloadHash");
var prepareRequest_1 = require("./prepareRequest");
var moveHeadersToQuery_1 = require("./moveHeadersToQuery");
var constants_1 = require("./constants");
var protocol_timestamp_1 = require("@aws-sdk/protocol-timestamp");
var util_hex_encoding_1 = require("@aws-sdk/util-hex-encoding");
var hasHeader_1 = require("./hasHeader");
var SignatureV4 = /** @class */ (function () {
    function SignatureV4(_a) {
        var applyChecksum = _a.applyChecksum, credentials = _a.credentials, region = _a.region, service = _a.service, sha256 = _a.sha256, _b = _a.uriEscapePath, uriEscapePath = _b === void 0 ? true : _b;
        this.service = service;
        this.sha256 = sha256;
        this.uriEscapePath = uriEscapePath;
        // default to true if applyChecksum isn't set
        this.applyChecksum = typeof applyChecksum === 'boolean' ? applyChecksum : true;
        if (typeof region === 'string') {
            var promisified_1 = Promise.resolve(region);
            this.regionProvider = function () { return promisified_1; };
        }
        else {
            this.regionProvider = region;
        }
        if (typeof credentials === 'object') {
            var promisified_2 = Promise.resolve(credentials);
            this.credentialProvider = function () { return promisified_2; };
        }
        else {
            this.credentialProvider = credentials;
        }
    }
    SignatureV4.prototype.presignRequest = function (originalRequest, expiration, options) {
        if (options === void 0) { options = {}; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a, region, credentials, _b, signingDate, unsignableHeaders, _c, longDate, shortDate, ttl, scope, request, canonicalHeaders, _d, _e, _f, _g, _h, _j;
            return tslib_1.__generator(this, function (_k) {
                switch (_k.label) {
                    case 0: return [4 /*yield*/, Promise.all([
                            this.regionProvider(),
                            this.credentialProvider()
                        ])];
                    case 1:
                        _a = _k.sent(), region = _a[0], credentials = _a[1];
                        _b = options.signingDate, signingDate = _b === void 0 ? new Date() : _b, unsignableHeaders = options.unsignableHeaders;
                        _c = formatDate(signingDate), longDate = _c.longDate, shortDate = _c.shortDate;
                        ttl = getTtl(signingDate, expiration);
                        if (ttl > constants_1.MAX_PRESIGNED_TTL) {
                            return [2 /*return*/, Promise.reject('Signature version 4 presigned URLs'
                                    + ' must have an expiration date less than one week in'
                                    + ' the future')];
                        }
                        scope = credentialDerivation_1.createScope(shortDate, region, this.service);
                        request = moveHeadersToQuery_1.moveHeadersToQuery(prepareRequest_1.prepareRequest(originalRequest));
                        if (credentials.sessionToken) {
                            request.query[constants_1.TOKEN_QUERY_PARAM] = credentials.sessionToken;
                        }
                        request.query[constants_1.ALGORITHM_QUERY_PARAM] = constants_1.ALGORITHM_IDENTIFIER;
                        request.query[constants_1.CREDENTIAL_QUERY_PARAM] = credentials.accessKeyId + "/" + scope;
                        request.query[constants_1.AMZ_DATE_QUERY_PARAM] = longDate;
                        request.query[constants_1.EXPIRES_QUERY_PARAM] = ttl.toString(10);
                        canonicalHeaders = getCanonicalHeaders_1.getCanonicalHeaders(request, unsignableHeaders);
                        request.query[constants_1.SIGNED_HEADERS_QUERY_PARAM] = getCanonicalHeaderList(canonicalHeaders);
                        _d = request.query;
                        _e = constants_1.SIGNATURE_QUERY_PARAM;
                        _f = this.getSignature;
                        _g = [longDate,
                            scope,
                            this.getSigningKey(credentials, region, shortDate)];
                        _h = this.createCanonicalRequest;
                        _j = [request,
                            canonicalHeaders];
                        return [4 /*yield*/, getPayloadHash_1.getPayloadHash(originalRequest, this.sha256)];
                    case 2: return [4 /*yield*/, _f.apply(this, _g.concat([_h.apply(this, _j.concat([_k.sent()]))]))];
                    case 3:
                        _d[_e] = _k.sent();
                        return [2 /*return*/, request];
                }
            });
        });
    };
    SignatureV4.prototype.sign = function (toSign, _a) {
        if (_a === void 0) { _a = {}; }
        var _b = _a.signingDate, signingDate = _b === void 0 ? new Date() : _b, options = tslib_1.__rest(_a, ["signingDate"]);
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _c, region, credentials, unsignableHeaders;
            return tslib_1.__generator(this, function (_d) {
                switch (_d.label) {
                    case 0: return [4 /*yield*/, Promise.all([
                            this.regionProvider(),
                            this.credentialProvider()
                        ])];
                    case 1:
                        _c = _d.sent(), region = _c[0], credentials = _c[1];
                        if (typeof toSign === 'string') {
                            return [2 /*return*/, this.signString(toSign, signingDate, region, credentials)];
                        }
                        else {
                            unsignableHeaders = options.unsignableHeaders;
                            return [2 /*return*/, this.signRequest(toSign, signingDate, region, credentials, unsignableHeaders)];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    SignatureV4.prototype.signString = function (stringToSign, signingDate, region, credentials) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var shortDate, hash, _a, _b, _c;
            return tslib_1.__generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        shortDate = formatDate(signingDate).shortDate;
                        _b = (_a = this.sha256).bind;
                        return [4 /*yield*/, this.getSigningKey(credentials, region, shortDate)];
                    case 1:
                        hash = new (_b.apply(_a, [void 0, _d.sent()]))();
                        hash.update(stringToSign);
                        _c = util_hex_encoding_1.toHex;
                        return [4 /*yield*/, hash.digest()];
                    case 2: return [2 /*return*/, _c.apply(void 0, [_d.sent()])];
                }
            });
        });
    };
    SignatureV4.prototype.signRequest = function (originalRequest, signingDate, region, credentials, unsignableHeaders) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var request, _a, longDate, shortDate, scope, payloadHash, canonicalHeaders, signature;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        request = prepareRequest_1.prepareRequest(originalRequest);
                        _a = formatDate(signingDate), longDate = _a.longDate, shortDate = _a.shortDate;
                        scope = credentialDerivation_1.createScope(shortDate, region, this.service);
                        request.headers[constants_1.AMZ_DATE_HEADER] = longDate;
                        if (credentials.sessionToken) {
                            request.headers[constants_1.TOKEN_HEADER] = credentials.sessionToken;
                        }
                        return [4 /*yield*/, getPayloadHash_1.getPayloadHash(request, this.sha256)];
                    case 1:
                        payloadHash = _b.sent();
                        if (!hasHeader_1.hasHeader(constants_1.SHA256_HEADER, request.headers) && this.applyChecksum) {
                            request.headers[constants_1.SHA256_HEADER] = payloadHash;
                        }
                        canonicalHeaders = getCanonicalHeaders_1.getCanonicalHeaders(request, unsignableHeaders);
                        return [4 /*yield*/, this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate), this.createCanonicalRequest(request, canonicalHeaders, payloadHash))];
                    case 2:
                        signature = _b.sent();
                        request.headers[constants_1.AUTH_HEADER] = constants_1.ALGORITHM_IDENTIFIER + " "
                            + ("Credential=" + credentials.accessKeyId + "/" + scope + ", ")
                            + ("SignedHeaders=" + getCanonicalHeaderList(canonicalHeaders) + ", ")
                            + ("Signature=" + signature);
                        return [2 /*return*/, request];
                }
            });
        });
    };
    SignatureV4.prototype.createCanonicalRequest = function (request, canonicalHeaders, payloadHash) {
        var sortedHeaders = Object.keys(canonicalHeaders).sort();
        return request.method + "\n" + this.getCanonicalPath(request) + "\n" + getCanonicalQuery_1.getCanonicalQuery(request) + "\n" + sortedHeaders.map(function (name) { return name + ":" + canonicalHeaders[name]; }).join('\n') + "\n\n" + sortedHeaders.join(';') + "\n" + payloadHash;
    };
    SignatureV4.prototype.createStringToSign = function (longDate, credentialScope, canonicalRequest) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var hash, hashedRequest;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        hash = new this.sha256();
                        hash.update(canonicalRequest);
                        return [4 /*yield*/, hash.digest()];
                    case 1:
                        hashedRequest = _a.sent();
                        return [2 /*return*/, constants_1.ALGORITHM_IDENTIFIER + "\n" + longDate + "\n" + credentialScope + "\n" + util_hex_encoding_1.toHex(hashedRequest)];
                }
            });
        });
    };
    SignatureV4.prototype.getCanonicalPath = function (_a) {
        var path = _a.path;
        if (this.uriEscapePath) {
            var doubleEncoded = encodeURIComponent(path.replace(/^\//, ''));
            return "/" + doubleEncoded.replace(/%2F/g, '/');
        }
        return path;
    };
    SignatureV4.prototype.getSignature = function (longDate, credentialScope, keyPromise, canonicalRequest) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var stringToSign, hash, _a, _b, _c;
            return tslib_1.__generator(this, function (_d) {
                switch (_d.label) {
                    case 0: return [4 /*yield*/, this.createStringToSign(longDate, credentialScope, canonicalRequest)];
                    case 1:
                        stringToSign = _d.sent();
                        _b = (_a = this.sha256).bind;
                        return [4 /*yield*/, keyPromise];
                    case 2:
                        hash = new (_b.apply(_a, [void 0, _d.sent()]))();
                        hash.update(stringToSign);
                        _c = util_hex_encoding_1.toHex;
                        return [4 /*yield*/, hash.digest()];
                    case 3: return [2 /*return*/, _c.apply(void 0, [_d.sent()])];
                }
            });
        });
    };
    SignatureV4.prototype.getSigningKey = function (credentials, region, shortDate) {
        return credentialDerivation_1.getSigningKey(this.sha256, credentials, shortDate, region, this.service);
    };
    return SignatureV4;
}());
exports.SignatureV4 = SignatureV4;
function formatDate(now) {
    var longDate = protocol_timestamp_1.iso8601(now).replace(/[\-:]/g, '');
    return {
        longDate: longDate,
        shortDate: longDate.substr(0, 8),
    };
}
function getCanonicalHeaderList(headers) {
    return Object.keys(headers)
        .sort()
        .join(';');
}
function getTtl(start, expiration) {
    return Math.floor((protocol_timestamp_1.toDate(expiration).valueOf() - protocol_timestamp_1.toDate(start).valueOf()) / 1000);
}
//# sourceMappingURL=SignatureV4.js.map